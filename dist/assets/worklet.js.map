{
  "version": 3,
  "sources": ["../../src/audio/worklet.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\r\n\r\ntype WorkletMessage =\r\n  | { type: \"worklet-ready\"; sampleRate: number; bufferSize: number }\r\n  | { type: \"pitch\"; freqHz: number | null; confidence: number; rms: number };\r\n\r\nclass TunerProcessor extends AudioWorkletProcessor {\r\n  private ring: Float32Array;\r\n  private writeIndex = 0;\r\n\r\n  // analysis cadence\r\n  private hopFrames: number;\r\n  private framesUntilAnalysis: number;\r\n\r\n  // scratch buffers (allocated once to avoid GC)\r\n  private analysisBuf: Float32Array;\r\n  private yinDiff: Float32Array;\r\n  private yinCMND: Float32Array;\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    const bufferSize = 16384;\r\n    this.ring = new Float32Array(bufferSize);\r\n\r\n    // Analysis ~30Hz is a good starting point for responsiveness. Moved to 20.\r\n    this.hopFrames = Math.floor(sampleRate / 20);\r\n    this.framesUntilAnalysis = this.hopFrames;\r\n\r\n    // Window size: tradeoff between low-note support and latency.\r\n    // 2048 @ 48kHz \u2248 42.7ms, supports down to ~100Hz-ish with some stability.\r\n    // Increase later if you care about E2 (82Hz) stability.\r\n    const windowSize = 4096;\r\n    this.analysisBuf = new Float32Array(windowSize);\r\n\r\n    // YIN uses tau up to windowSize/2\r\n    const maxTau = Math.floor(windowSize / 2);\r\n    this.yinDiff = new Float32Array(maxTau);\r\n    this.yinCMND = new Float32Array(maxTau);\r\n\r\n    this.port.postMessage({\r\n      type: \"worklet-ready\",\r\n      sampleRate,\r\n      bufferSize: this.ring.length,\r\n    } satisfies WorkletMessage);\r\n  }\r\n\r\n  private pushBlock(input: Float32Array) {\r\n    const n = input.length;\r\n    const buf = this.ring;\r\n    const len = buf.length;\r\n\r\n    let i = 0;\r\n    while (i < n) {\r\n      const spaceToEnd = len - this.writeIndex;\r\n      const chunk = Math.min(spaceToEnd, n - i);\r\n      buf.set(input.subarray(i, i + chunk), this.writeIndex);\r\n      this.writeIndex = (this.writeIndex + chunk) % len;\r\n      i += chunk;\r\n    }\r\n  }\r\n\r\n  private copyLatestWindow(dest: Float32Array) {\r\n    const buf = this.ring;\r\n    const len = buf.length;\r\n    const n = dest.length;\r\n\r\n    // dest[0] is oldest, dest[n-1] is newest\r\n    let idx = (this.writeIndex - n + len) % len;\r\n    for (let i = 0; i < n; i++) {\r\n      dest[i] = buf[idx];\r\n      idx = (idx + 1) % len;\r\n    }\r\n  }\r\n\r\n  private computeRms(x: Float32Array): number {\r\n    let sumSq = 0;\r\n    for (let i = 0; i < x.length; i++) {\r\n      const v = x[i];\r\n      sumSq += v * v;\r\n    }\r\n    return Math.sqrt(sumSq / x.length);\r\n  }\r\n\r\n  /**\r\n   * YIN pitch detection.\r\n   * Returns {freqHz, confidence}. freqHz null if no good pitch.\r\n   *\r\n   * confidence is ~ 1 - (bestCMND), so higher is better.\r\n   */\r\n  private yinDetect(\r\n    x: Float32Array,\r\n    sampleRate: number,\r\n    diff: Float32Array,\r\n    cmnd: Float32Array\r\n  ): { freqHz: number | null; confidence: number } {\r\n    const n = x.length;\r\n    const maxTau = diff.length;\r\n\r\n    // 1) Difference function d(tau)\r\n    diff.fill(0);\r\n    for (let tau = 1; tau < maxTau; tau++) {\r\n      let sum = 0;\r\n      for (let i = 0; i < n - tau; i++) {\r\n        const d = x[i] - x[i + tau];\r\n        sum += d * d;\r\n      }\r\n      diff[tau] = sum;\r\n    }\r\n\r\n    // 2) Cumulative mean normalized difference function (CMND)\r\n    cmnd[0] = 1;\r\n    let runningSum = 0;\r\n    for (let tau = 1; tau < maxTau; tau++) {\r\n      runningSum += diff[tau];\r\n      cmnd[tau] = runningSum > 0 ? (diff[tau] * tau) / runningSum : 1;\r\n    }\r\n\r\n    // 3) Find first dip below threshold\r\n    const threshold = 0.15; // lower => stricter; 0.10-0.20 typical\r\n    let tauEstimate = -1;\r\n\r\n    for (let tau = 2; tau < maxTau; tau++) {\r\n      if (cmnd[tau] < threshold) {\r\n        // walk to local minimum\r\n        while (tau + 1 < maxTau && cmnd[tau + 1] < cmnd[tau]) {\r\n          tau++;\r\n        }\r\n        tauEstimate = tau;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (tauEstimate === -1) {\r\n      // fallback: global minimum (can be noisy, but better than nothing)\r\n      let minVal = 1e9;\r\n      let minTau = -1;\r\n      for (let tau = 2; tau < maxTau; tau++) {\r\n        const v = cmnd[tau];\r\n        if (v < minVal) {\r\n          minVal = v;\r\n          minTau = tau;\r\n        }\r\n      }\r\n      tauEstimate = minTau;\r\n      if (tauEstimate <= 0) return { freqHz: null, confidence: 0 };\r\n    }\r\n\r\n    // 4) Parabolic interpolation around tauEstimate for better accuracy\r\n    const tau = tauEstimate;\r\n    const x0 = tau > 1 ? cmnd[tau - 1] : cmnd[tau];\r\n    const x1 = cmnd[tau];\r\n    const x2 = tau + 1 < maxTau ? cmnd[tau + 1] : cmnd[tau];\r\n\r\n    const denom = (2 * x1 - x2 - x0);\r\n    const betterTau =\r\n      denom !== 0 ? tau + (x2 - x0) / (2 * denom) : tau;\r\n\r\n    const freqHz = betterTau > 0 ? sampleRate / betterTau : null;\r\n\r\n    // Confidence: invert CMND at the selected tau (clamp 0..1)\r\n    const rawConf = 1 - x1;\r\n    const confidence = Math.max(0, Math.min(1, rawConf));\r\n\r\n    // Clamp frequency to a sane range for a tuner\r\n    if (freqHz === null || freqHz < 60 || freqHz > 1200) {\r\n      return { freqHz: null, confidence: 0 };\r\n    }\r\n\r\n    return { freqHz, confidence };\r\n  }\r\n\r\n  process(inputs: Float32Array[][]) {\r\n    const input = inputs[0]?.[0];\r\n    if (input && input.length > 0) {\r\n      this.pushBlock(input);\r\n\r\n      this.framesUntilAnalysis -= input.length;\r\n      if (this.framesUntilAnalysis <= 0) {\r\n        this.framesUntilAnalysis += this.hopFrames;\r\n\r\n        // Pull latest window\r\n        this.copyLatestWindow(this.analysisBuf);\r\n\r\n        // Basic silence gate\r\n        const rms = this.computeRms(this.analysisBuf);\r\n        if (rms < 0.002) {\r\n          this.port.postMessage({\r\n            type: \"pitch\",\r\n            freqHz: null,\r\n            confidence: 0,\r\n            rms,\r\n          } satisfies WorkletMessage);\r\n          return true;\r\n        }\r\n\r\n        const { freqHz, confidence } = this.yinDetect(\r\n          this.analysisBuf,\r\n          sampleRate,\r\n          this.yinDiff,\r\n          this.yinCMND\r\n        );\r\n\r\n        // Hysteresis on octave\r\n        let f = freqHz;\r\n        let c = confidence;\r\n\r\n        // If we got a pitch but it's unstable, try octave correction:\r\n        // If we're near E3 but the signal is likely an E2 fundamental,\r\n        // checking f/2 often stabilizes.\r\n        if (f !== null) {\r\n            // Only attempt correction in guitar-ish low range where octave errors are common\r\n            if (f > 120 && f < 400) {\r\n                const half = f / 2;\r\n                // Treat half frequency as candidate if it's still in range\r\n                if (half >= 60) {\r\n                    // Compute how well half fits by checking cents proximity to nearest MIDI note\r\n                    // We can\u2019t do full note mapping in worklet cheaply, but we can use a ratio test:\r\n                    // If f is close to 2x of a stable fundamental, half will often be more stable over time.\r\n                    // Heuristic: prefer half if confidence is mediocre (harmonic lock) and RMS is decent.\r\n                    if (c < 0.75) {\r\n                        f = half;\r\n                        // reduce confidence slightly (it\u2019s a heuristic)\r\n                        c = Math.max(0, c - 0.05);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Gate on confidence too\r\n        const ok = f !== null && confidence > 0.75;\r\n\r\n        this.port.postMessage({\r\n          type: \"pitch\",\r\n          freqHz: ok ? f : null,\r\n          confidence: c,\r\n          rms,\r\n        } satisfies WorkletMessage);\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n}\r\n\r\nregisterProcessor(\"tuner\", TunerProcessor);\r\n"],
  "mappings": "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",
  "names": ["sampleRate", "tau"]
}
